#!/usr/bin/python3
"""
This script reads the data file produced by notify.py and checks if the
users that were notified have hearted the notification post.  Based on
that it removes them from the group as appropriate.

Parameters:
  data_file: The path to the data file generated by notify.py
  for_realz: Really prune people (otherwise don't, just report the results as
    if you would)  
  
Data for a given run is stored under data/<group_id>/<YYMMDDHHMMSS>

Logs are under data/logs 

"""

import argparse
from datetime import datetime
from datetime import timedelta
import glob
import groupy  # https://github.com/rhgrant10/Groupy
import logging
import os
import pickle

logger = logging.getLogger('notify')
logger.setLevel(logging.DEBUG)

now =  datetime.now()

scriptdir = os.path.dirname(os.path.abspath(__file__))
datadir = scriptdir + '/data/'

logfile = logging.FileHandler(datadir + "/logs/prune.log")
console = logging.StreamHandler()

logformat = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
logfile.setFormatter(logformat)

conformat = logging.Formatter('%(levelname)s - %(message)s')
logfile.setFormatter(conformat)

logfile.setLevel(logging.DEBUG)
console.setLevel(logging.DEBUG)

logger.addHandler(logfile)
logger.addHandler(console)

parser = argparse.ArgumentParser(description = 'Remove inactive group members')
parser.add_argument('data_file',
                    type=str,
                    help='The data file to be processed')
parser.add_argument('--for_realz',
                    action='store_true',
                    help='Really prune the group...')
args = parser.parse_args()

"""
Given a data file name, return the most recent revision
"""
def selectNewestDataFile(filename):
  print(filename)
  if not os.path.isfile(filename):
    logger.error('{0} is not a file.'.format(filename))
    
  (head, tail) = os.path.split(filename)
  prefix = tail[:14]

  pattern = head + '/' + prefix + '*'
  logger.debug('Getting all files matching {0}'.format(pattern))
  dir_entries = glob.glob(pattern)
  dir_entries.sort()

  revision_name = head + '/' + dir_entries[-1]
  logger.debug("Selecting {0} as the most recent data file version".format(revision_name))
  return revision_name


"""
Given a data file name return the next revision
"""
def selectNextDataFile(filename):
  (head, tail) = os.path.split(filename)
  print(head, tail)
  prefix = tail[:14]
  if len(tail) > 14:
    suffix = int(tail[15:])
  else:
    suffix = 0
  
  suffix += 1
  
  revison_name = head + '/' + prefix + '.' + str(suffix)
  logger.debug("Selecting {0} as the next data file version".format(revison_name))
  return revison_name
    
#
# Main program
#
filename = selectNewestDataFile(args.data_file)

with open(filename, 'rb') as f:
    member_status = pickle.load(f)

print(member_status)

filename = selectNextDataFile(filename)


# Save updated member status in a new file, named with the same YYYYMMDDHHMMSS
# as the source file, but with an incremented number at the end.  So if the file
# we read was 20150504123445 then the new file is 20150504123445.1, and if the
# source file was .1 then the new file is .2



