#!/usr/bin/python3
"""
This script reads the data file produced by notify.py and checks if the
users that were notified have hearted the notification post.  Based on
that it removes them from the group as appropriate.

Parameters:
  data_file: The path to the data file generated by notify.py
  for_realz: Really prune people (otherwise don't, just report the results as
    if you would)  
  
Data for a given run is stored under data/<group_id>/<YYMMDDHHMMSS>

Logs are under data/logs 

"""

import argparse
from datetime import datetime
from datetime import timedelta
from glob import glob
import groupy  # https://github.com/rhgrant10/Groupy
import logging
import os
import pickle

parser = argparse.ArgumentParser(description = 'Remove inactive group members')
parser.add_argument('data_file',
                    type=str,
                    help='The data file to be processed')
parser.add_argument('--for_realz',
                    action='store_true',
                    help='Really prune the group...')

SCRIPTDIR = os.path.dirname(os.path.realpath(__file__))
DATADIR = SCRIPTDIR + '/data'

LOG = logging.getLogger('prune')
LOG.setLevel(logging.DEBUG)


"""
Given a data file name, return the most recent revision
"""
def selectNewestDataFile(filename):
    print(filename)
    if not os.path.isfile(filename):
        LOG.error('{0} is not a file.'.format(filename))
      
    (head, tail) = os.path.split(filename)
    prefix = tail[:14]
  
    pattern = head + '/' + prefix + '*'
    LOG.debug('Getting all files matching {0}'.format(pattern))
    dir_entries = glob(pattern)
    dir_entries.sort()
  
    LOG.debug("Selecting {0} as the most recent data file version".format(dir_entries[-1]))
    return dir_entries[-1]


"""
Given a data file name return the next revision
"""
def selectNextDataFile(filename):
    (head, tail) = os.path.split(filename)
    prefix = tail[:14]
    if len(tail) > 14:
        suffix = int(tail[15:])
    else:
        suffix = 0
    
    suffix += 1
    
    revison_name = head + '/' + prefix + '.' + str(suffix)
    LOG.debug("Selecting {0} as the next data file version".format(revison_name))
    return revison_name


"""Find the group object given a group ID"""
def findGroupFromID(group_id, group_class = groupy.Group):
    target_group = None
    for g in group_class.list():
        if g.group_id == group_id:
            LOG.info('Found group id {0} "{1}"'.format(g.group_id, g.name))
            target_group = g
            break
    if not target_group:
        LOG.error('Could not find group id {0}'.format(group_id))
    return target_group


"""Get the group given the data file path"""
def getGroupFromDataFilePath(path):
    (head, tail) = os.path.split(path)
    if os.path.islink(head):
        head = os.readlink(head)
    (head, group_id) = os.path.split(head)
    
    group = findGroupFromID(group_id)  
    return group


"""Main program"""
def main(args):

    os.makedirs(DATADIR + '/logs', mode = 0o777, exist_ok = True)
    
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
    LOG.addHandler(ch)
    
    fh = logging.FileHandler(DATADIR + "/logs/prune.log")
    fh.setLevel(logging.DEBUG)
    fh.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    LOG.addHandler(fh)
    
    now =  datetime.now()
    
    group = getGroupFromDataFilePath(args.data_file)
    
    filename = selectNewestDataFile(args.data_file)
    
    with open(filename, 'rb') as f:
        member_status = pickle.load(f)
    
    # TODO(ken): Load PMs and check for responses.  Return list of people to be removed
    
    # Save updated member status in a new file, named with the same YYYYMMDDHHMMSS
    # as the source file, but with an incremented number at the end.  So if the file
    # we read was 20150504123445 then the new file is 20150504123445.1, and if the
    # source file was .1 then the new file is .2    
    
    filename = selectNextDataFile(filename)
    with open(filename, 'wb') as f:
        
        # TODO(ken): Send message to group, to inactive members, and remove them
        # TODO(ken): Remove them from status structure
        
        pickle.dump(member_status, f)
    
    
if __name__ == "__main__":
    args = parser.parse_args()
    main(args)



